# Platform

I found the loading times of the stars and constellations to be intolerable, so I set out to create a multithread system where one thread would load stars and post events back to the main thread for any interactions with the Unity API that I needed (such as creating new GameObjects). Overall, this did increase memory usage as variables needed to be persisted among threads to avoid any unfortunate race conditions but allowed the application to start up right away and load objects in the background. The background thread posts actions to the main thread. To start loading constellations after the stars, the star thread posts an action that creates a new thread to load the constellations.

I was unable to test on CAVE2 so this section will be geared toward the HTC Vive. I initially had a sphere GameObject for each star with the ultimate goal being to apply LOD groups to each so that at a far distance they could be billboards, but close up they would be spheres and have some smoke and fire particle effects. This caused over 100,000 game objects to be created which slowed my application to 5 frames per second. I then transitioned to cubes with an unlit shader and no shadows, but there was no noticeable performance increase. From here I debated between two options: decrease the far culling plane or render the stars using the built-in Unity particle system. After trying the first option, I was unsatisfied in the number of stars that needed to be hidden to bring the framerate up to at least 30. This led me to create a particle system that emits one particle at the location of the stars defined in the database (with all physics effects turned off). I did leave my first solution intact since I needed to process the file anyway, but disabled the root object where all the stars are being spawned. My thought process here was that each node in CAVE2 might be able to each handle 1/#nodes of the objects and wanted to test it out.
